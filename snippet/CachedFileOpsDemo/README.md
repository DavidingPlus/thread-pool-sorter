# CachedFileOpsDemo

平时作业一。编写一个带缓存的文件操作类。

# 核心设计

## 块级缓存

* 文件被分成固定大小的块（默认 4KiB），每个块独立缓存。
* 每个缓存块包含：
  * 起始偏移 (`baseOffset`)
  * 数据有效长度 (`dataSize`)
  * 是否脏块 (`dirty`)
  * 数据缓冲区 (`data`)
* **块大小可调整**，通过 `m_blockSize` 设置。

## 文件注册与管理

* 文件通过 `addFile(filePath, fd)` 注册到管理器。
* 每个文件对应一个 `FileCache`，维护：
  * 文件描述符
  * 所有缓存块的映射 (`blocks`)
* 文件关闭时，会将所有脏块写回磁盘，并释放缓存。

## LRU 缓存策略

* 全局维护 LRU 列表 `m_lruList`，记录 `(filePath, blockBaseOffset)`。
* 每次访问块都会更新 LRU，将其移到列表头部。
* 当缓存块数超过上限时，自动淘汰最久未使用块：
  * 若块脏，则写回磁盘。
  * 从文件缓存和 LRU 索引中删除。
  * 更新当前缓存块数 `m_curBlocks`。

## 线程安全

* 内部使用 `std::mutex` 保护缓存操作。
* 读写、块加载、淘汰、flush 等操作均加锁。
* 多线程环境下可安全使用单例管理器。

## 读写流程

### 读操作

1. 根据 `offset` 定位块起始 (`blockBase`)。
2. 调用 `ensureBlock`：
   * 若块已缓存，则直接返回。
   * 否则从磁盘读取并插入缓存。
3. 从块内偏移位置复制数据到用户缓冲区。
4. 更新偏移量和 LRU。

### 写操作

1. 定位对应块
2. 调用 `ensureBlock` 加载或创建块。
3. 拷贝数据到块缓冲区，并更新 `dataSize`。
4. 标记 `dirty = true`。
5. 更新 LRU，触发淘汰（如必要）。

## 缓存淘汰和写回

* 淘汰时：
  * 先检查块是否为脏块。
  * 若是，则写回磁盘。
* 提供 `flush(filePath)` 和 `flushAll()` 接口：
  * 可手动写回脏块。
  * 析构时自动 flush 所有文件。

## 7. 单例模式

* `LCacheManager` 为单例，确保系统中只有一个全局缓存管理器
* 好处：
  * 跨模块共享缓存。
  * 避免重复维护文件缓存和 fd。
  * 简化线程安全设计。

